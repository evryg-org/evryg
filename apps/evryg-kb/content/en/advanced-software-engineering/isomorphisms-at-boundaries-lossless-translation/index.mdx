---
canonical-slug: isomorphismes-aux-frontieres-traduction-sans-perte-d-information
pageType: article
---

# Isomorphisms at Boundaries: Lossless Translation

An isomorphism between two types $A$ and $B$ is a pair of functions $\text{to} : A \to B$ and $\text{from} : B \to A$ such that $\text{from}(\text{to}(a)) = a$ and $\text{to}(\text{from}(b)) = b$ for any value.

In other words, we can convert in one direction then the other without losing information: the two types are structurally equivalent, simply dressed differently. At application boundaries, where data crosses membranes between heterogeneous systems, this notion becomes a precious conceptual tool for reasoning about transformation fidelity.

## The Multiple Boundaries of an Application

An application's boundaries are multiple, including:

- HTTP APIs receiving JSON
- Reading CSV files
- Communication with a database
- Calls to external services
- Serialization for caching

At each crossing, data changes representation: from memory objects to text, from text to typed structures, from one schema to another.

The ideal is for these transformations to be isomorphic: what goes out can be reconstructed identically at the input. When this ideal is achieved, we have the guarantee that no business information is corrupted or lost during transit.

## Partial Isomorphisms and Injections

In practice, perfect isomorphisms are rare at real boundaries:

- JSON doesn't distinguish integers from floats
- XML imposes an order on elements that our domain might ignore
- Relational databases flatten nested structures

We then work with partial isomorphisms or injections: the `to` transformation preserves all information, but `from` is only defined on the image of `to`.

Explicitly recognizing these limitations guides design. If our domain type contains distinctions that the target format cannot represent, we either enrich the format, consciously accept the loss, or rethink the source type.

## Link to "Parse, Don't Validate"

The [Parse, don't validate](/en/advanced-software-engineering/parse-dont-validate) approach naturally fits within this framework.

Parsing at the incoming boundary attempts to construct a partial isomorphism: from the broad, untrusted type (`unknown`, `string`, raw JSON) to the precise domain type. If the incoming data doesn't belong to the expected image, parsing fails explicitly.

Outgoing serialization constitutes the other direction: from the domain type to a transmissible format. When these two directions are inverses of each other, we have a *codec* (an encapsulated isomorphism) and property tests can automatically verify the round-trip:

$$\text{decode}(\text{encode}(x)) = x$$

for any value $x$ in the domain.

Note that such a round-trip property is useful in [property-based testing](/en/advanced-software-engineering/property-based-testing-power-and-limits).

## Architectural Discipline

This isomorphic perspective encourages healthy architectural discipline.

It pushes us to define canonical types at the domain's core, independent of any external representation, then maintain explicit translation layers toward each peripheral format. This is essential in ports & adapters (hexagonal) or clean architecture, for example.

Each translation layer becomes testable in isolation: we verify the round-trip, we verify error case handling. Schema evolutions (new fields, modified types, API versions) are negotiated in these translation layers rather than contaminating the domain.

Isomorphism, even when it's only an approximated ideal, provides an objective quality criterion: the closer our transformations come to it, the more reliable our data exchanges are.
